<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DiamondMiner ‚Äî Marketplace</title>

  <!-- Tailwind (keeps your theme consistent) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root{
      --bg:#0b0f17;
      --card:#121827;
      --muted:#6b7280;
      --accent:#4ae3ff;
      --panel-border: rgba(255,255,255,0.05);
    }
    body{
      background: radial-gradient(circle at top, #060812 0%, var(--bg) 100%);
      color: #fff;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin:0;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* NAVBAR */
    header { background: #05060d90; backdrop-filter: blur(6px); border-bottom:1px solid var(--panel-border); }
    .nav-inner { max-width:1120px; margin:0 auto; display:flex; align-items:center; justify-content:space-between; padding:14px 20px; }
    .nav-links a { color:#cbd5e1; margin-left:18px; text-decoration:none; font-weight:500; }
    .nav-links a.active, .nav-links a:hover{ color: var(--accent); }

    /* Page heading */
    .page-hero { max-width:1120px; margin:92px auto 18px; padding: 0 20px; text-align:center; }
    .page-hero h1 { font-weight:800; font-size:30px; color:var(--accent); letter-spacing:-0.02em; }

    /* Marketplace grid */
    .marketplace-container { max-width:1120px; margin:18px auto 40px; padding:0 20px; display:grid; gap:22px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }

    .item-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.012));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius:14px;
      padding:22px;
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      transition: transform .16s ease, box-shadow .16s ease;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
      min-height: 360px;
    }
    .item-card:hover{ transform: translateY(-6px); box-shadow: 0 18px 40px rgba(2,6,23,0.75); }

    .item-img-wrapper { width:100%; height:180px; display:flex; align-items:center; justify-content:center; margin-bottom:12px; }
    .item-img-wrapper img { max-width:170px; max-height:170px; object-fit:contain; display:block; }

    .item-title { color:var(--accent); font-weight:700; font-size:20px; margin-bottom:8px; }
    .item-info { color:#cbd5e1; margin-bottom:10px; line-height:1.5; }

    .locked { opacity:.34; filter: grayscale(90%); pointer-events:none; transform:none; }
    .price { font-weight:700; color:#9fffae; margin-top:4px; }

    .buy-btn {
      margin-top:auto;
      width:160px;
      padding:10px 14px;
      border-radius:10px;
      border:0;
      cursor:pointer;
      font-weight:700;
      color:#07121a;
      background: linear-gradient(90deg,#2cd4ff,#4aa6ff);
      box-shadow: 0 6px 18px rgba(46,191,255,0.12);
    }
    .buy-btn[disabled] { opacity:.5; cursor:not-allowed; background:#4b5563; color:#ddd; box-shadow:none; }

    /* Balance box under header */
    .balance-bar { max-width:1120px; margin:8px auto; padding:12px 20px; display:flex; align-items:center; justify-content:center; gap:16px; color:#cfefff; font-weight:600; }
    .balance-pill { background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.02); padding:8px 12px; border-radius:999px; }

    /* Coming features: one row centered */
    .coming-wrap { max-width:1120px; margin:40px auto 30px; padding:0 20px; display:flex; justify-content:center; gap:18px; flex-wrap:wrap; }
    .feature {
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:18px;
      border-radius:12px;
      width:280px;
      text-align:center;
    }
    .feature h3 { color:var(--accent); margin-bottom:8px; font-weight:700; }
    .feature p { color:#cbd5e1; font-size:14px; }

    footer { margin-top:32px; border-top:1px solid rgba(255,255,255,0.03); padding:22px 0; text-align:center; color:#9ca3af; }

    /* small responsive tweaks */
    @media (max-width:520px){
      .item-card { min-height: 340px; padding:18px; }
      .buy-btn { width:100%; }
      .feature { width: 100%; max-width: 420px; }
    }
  </style>
</head>
<body>

  <!-- NAVBAR -->
  <header>
    <div class="nav-inner">
      <a href="index.html" class="flex items-center gap-3">
        <img src="images/diamond-icon.png" class="w-8 h-8" alt="logo" />
        <span style="color:var(--accent);font-weight:800;">DiamondMiner</span>
      </a>

      <nav class="nav-links">
        <a href="index.html">Home</a>
        <a href="dashboard.html">Dashboard</a>
        <a href="marketplace.html" class="active">Marketplace</a>
        <a href="tokenomics.html">Tokenomics</a>
        <a href="whitepaper.html">Whitepaper</a>
      </nav>
    </div>
  </header>

  <!-- PAGE HERO -->
  <section class="page-hero">
    <h1>Diamond Miner ‚Äî Marketplace</h1>
  </section>

  <!-- BALANCE -->
  <div class="balance-bar" aria-live="polite">
    <div class="balance-pill">Connected wallet: <span id="walletAddressDisplay">‚Äî</span></div>
    <div class="balance-pill">Spendable $DIA (claimed): <span id="spendableDia">0.00</span></div>
    <div class="balance-pill">Unclaimed mining balance: <span id="unclaimedBalance">0.00</span></div>
  </div>

  <!-- MARKETPLACE GRID -->
  <section class="marketplace-container" id="marketplaceGrid">

    <!-- DMiner -->
    <div class="item-card" id="card-dminer">
      <div class="item-img-wrapper"><img src="images/dminer.png" alt="DMiner" /></div>
      <div class="item-title">DMiner</div>
      <div class="item-info">Mining Rate: <strong>+0.02 $DIA / min</strong><br><span class="price">Price: 50 $DIA</span></div>
      <button class="buy-btn" id="buy-dminer" onclick="attemptBuy('dminer')">BUY</button>
    </div>

    <!-- Drill 1 -->
    <div class="item-card locked" id="card-drill1">
      <div class="item-img-wrapper"><img src="images/drill1.png" alt="Drill 1" /></div>
      <div class="item-title">Drill 1</div>
      <div class="item-info">Mining Rate: <strong>+0.03 $DIA / min</strong><br><span class="price">Price: 75 $DIA</span></div>
      <button class="buy-btn" id="buy-drill1" onclick="attemptBuy('drill1')" disabled>BUY</button>
    </div>

    <!-- Drill 2 -->
    <div class="item-card locked" id="card-drill2">
      <div class="item-img-wrapper"><img src="images/drill2.png" alt="Drill 2" /></div>
      <div class="item-title">Drill 2</div>
      <div class="item-info">Mining Rate: <strong>+0.05 $DIA / min</strong> (Stackable)<br><span class="price">Price: 110 $DIA</span></div>
      <button class="buy-btn" id="buy-drill2" onclick="attemptBuy('drill2')" disabled>BUY</button>
    </div>

  </section>

  <!-- COMING FEATURES (centered in one row) -->
  <section class="coming-wrap" aria-hidden="true">
    <div class="feature">
      <h3>üíé Rare Boosters</h3>
      <p>Enhance your mining efficiency with limited-edition NFT boosters.</p>
    </div>
    <div class="feature">
      <h3>‚öôÔ∏è Mining Equipment</h3>
      <p>Upgrade your digital rigs and increase your $DIA yield rate.</p>
    </div>
    <div class="feature">
      <h3>üè™ Player Trades</h3>
      <p>Buy and sell NFTs with other miners directly in the marketplace.</p>
    </div>
  </section>

  <footer>
    ¬© 2025 DiamondMiner ‚Äî All Rights Reserved.
  </footer>

  <script>
    /*******************************
      Marketplace logic (Option A)
      - Uses the same wallet storage keys as your dashboard:
        - localStorage.walletAddress -> active wallet
        - localStorage[wallet + "_data"] -> JSON with wallet data (balance, totalDia, miningActive, lastMineTime, extraRate, etc)
        - localStorage[wallet + "_owned"] -> JSON array of owned items (persisted)
      - If no wallet connected, fallback to localStorage.diaBalance for quick testing
    *******************************/

    // Item catalog (rates in $DIA/min and price)
    const CATALOG = {
      dminer: { id: 'dminer', title: 'DMiner', rate: 0.02, price: 50 },
      drill1: { id: 'drill1', title: 'Drill 1', rate: 0.03, price: 75 },
      drill2: { id: 'drill2', title: 'Drill 2', rate: 0.05, price: 110 } // stackable
    };

    // Helpers for storage
    function getActiveWallet() {
      return localStorage.getItem('walletAddress') || null;
    }

    function readWalletData(wallet) {
      if (!wallet) return null;
      const raw = localStorage.getItem(wallet + '_data');
      if (!raw) return null;
      try { return JSON.parse(raw); } catch(e){ return null; }
    }

    function writeWalletData(wallet, obj) {
      if (!wallet) return;
      localStorage.setItem(wallet + '_data', JSON.stringify(obj));
    }

    function readOwned(wallet) {
      const raw = localStorage.getItem(wallet + '_owned');
      if (!raw) return [];
      try { return JSON.parse(raw); } catch(e){ return []; }
    }

    function writeOwned(wallet, arr) {
      if (!wallet) return;
      localStorage.setItem(wallet + '_owned', JSON.stringify(arr));
    }

    // Fallback simple balance (dev/testing) if no wallet connected
    function ensureFallbackBalance() {
      if (!localStorage.getItem('diaBalance')) {
        // Give a test starting balance so you can test buy flow locally
        localStorage.setItem('diaBalance', '200');
      }
    }

    // UI elements
    const walletDisplay = document.getElementById('walletAddressDisplay');
    const spendableEl = document.getElementById('spendableDia');
    const unclaimedEl = document.getElementById('unclaimedBalance');

    // Buttons / cards
    const btns = {
      dminer: document.getElementById('buy-dminer'),
      drill1: document.getElementById('buy-drill1'),
      drill2: document.getElementById('buy-drill2')
    };
    const cards = {
      dminer: document.getElementById('card-dminer'),
      drill1: document.getElementById('card-drill1'),
      drill2: document.getElementById('card-drill2')
    };

    // Initialize UI on load
    function initMarketplace() {
      ensureFallbackBalance();

      const wallet = getActiveWallet();
      if (wallet) {
        walletDisplay.textContent = wallet.slice(0,6) + '...' + wallet.slice(-4);
      } else {
        walletDisplay.textContent = 'Not connected';
      }

      // load data depending on wallet presence
      let spendable, unclaimed;
      if (wallet) {
        const data = readWalletData(wallet) || {};
        // We consider spendable = totalDia (claimed), and unclaimed = balance (mining balance not yet claimed)
        spendable = parseFloat(data.totalDia || 0);
        unclaimed = parseFloat(data.balance || 0);
      } else {
        spendable = parseFloat(localStorage.getItem('diaBalance') || 0);
        unclaimed = 0;
      }

      updateSpendableUI(spendable, unclaimed);
      restoreOwnedUI(wallet);
      updateButtonsState();
      // update countdowns etc if needed (not used here)
    }

    function updateSpendableUI(spendable, unclaimed) {
      spendableEl.textContent = Number(spendable || 0).toFixed(4);
      unclaimedEl.textContent = Number(unclaimed || 0).toFixed(4);
    }

    // Check if user can afford an item
    function canAfford(itemKey) {
      const wallet = getActiveWallet();
      let spendable = 0;
      if (wallet) {
        const data = readWalletData(wallet) || {};
        spendable = parseFloat(data.totalDia || 0);
      } else {
        spendable = parseFloat(localStorage.getItem('diaBalance') || 0);
      }
      return spendable >= CATALOG[itemKey].price;
    }

    // Update buttons (enable/disable) and locks based on ownership and prerequisites
    function updateButtonsState() {
      const wallet = getActiveWallet();
      const owned = wallet ? readOwned(wallet) : JSON.parse(localStorage.getItem('owned_fallback') || '[]');

      // DMiner always purchasable (if you have funds)
      toggleCardState('dminer', owned.includes('dminer') ? 'owned' : (canAfford('dminer') ? 'buyable' : 'locked'));

      // Drill1 requires DMiner
      if (!owned.includes('dminer')) {
        toggleCardState('drill1', 'locked');
      } else {
        toggleCardState('drill1', owned.includes('drill1') ? 'owned' : (canAfford('drill1') ? 'buyable' : 'locked'));
      }

      // Drill2 requires Drill1
      if (!owned.includes('drill1')) {
        toggleCardState('drill2', 'locked');
      } else {
        toggleCardState('drill2', 'buyable-or-owned', owned.includes('drill2') ? 'owned' : (canAfford('drill2') ? 'buyable' : 'locked'));
        // drill2 is stackable ‚Äî owning it doesn't "prevent" another buy in UI; we treat "owned" for single-click state,
        // but we still allow stack purchases (see attemptBuy logic)
      }
    }

    // Changes card visual state and button enabling
    function toggleCardState(key, state) {
      // state: 'locked' | 'buyable' | 'owned' | 'buyable-or-owned'
      const card = cards[key];
      const btn = btns[key];
      if (!card || !btn) return;

      // Reset
      card.classList.remove('locked');
      btn.disabled = false;
      btn.textContent = 'BUY';

      if (state === 'locked') {
        card.classList.add('locked');
        btn.disabled = true;
      } else if (state === 'buyable') {
        card.classList.remove('locked');
        btn.disabled = false;
      } else if (state === 'owned') {
        card.classList.remove('locked');
        btn.disabled = true;
        btn.textContent = 'OWNED';
      } else if (state === 'buyable-or-owned') {
        // for drill2: if owned at least once show "OWNED (stackable)" but still allow additional purchases
        const wallet = getActiveWallet();
        const ownedArr = wallet ? readOwned(wallet) : JSON.parse(localStorage.getItem('owned_fallback') || '[]');
        if (ownedArr.includes('drill2')) {
          btn.disabled = false; // allow stacking -> enable
          btn.textContent = 'BUY (stack)';
          card.classList.remove('locked');
        } else {
          btn.disabled = false;
          btn.textContent = 'BUY';
          card.classList.remove('locked');
        }
      }
    }

    // Restore owned UI from storage
    function restoreOwnedUI(wallet) {
      const owned = wallet ? readOwned(wallet) : JSON.parse(localStorage.getItem('owned_fallback') || '[]');
      owned.forEach(id => {
        const card = cards[id];
        const btn = btns[id];
        if (card && btn) {
          // For DMiner and Drill1 mark as owned
          btn.textContent = (id === 'drill2') ? 'OWNED' : 'OWNED';
          btn.disabled = (id === 'drill2') ? false : true; // drill2 remains buyable for stacking, but mark as owned visually
        }
      });
    }

    // Attempt to buy an item (called by button)
    function attemptBuy(itemKey) {
      const wallet = getActiveWallet();
      let spendable = 0;
      let walletData = null;

      if (wallet) {
        walletData = readWalletData(wallet) || {};
        spendable = parseFloat(walletData.totalDia || 0);
      } else {
        spendable = parseFloat(localStorage.getItem('diaBalance') || 0);
      }

      const price = CATALOG[itemKey].price;
      if (spendable < price) {
        alert('‚ö†Ô∏è Not enough $DIA to buy ' + CATALOG[itemKey].title);
        return;
      }

      // Confirm purchase
      const ok = confirm(`Buy ${CATALOG[itemKey].title} for ${price} $DIA?`);
      if (!ok) return;

      // Deduct funds from the appropriate storage
      if (wallet) {
        walletData.totalDia = Number((parseFloat(walletData.totalDia || 0) - price).toFixed(8));
        // If buy uses unclaimed balance instead, adjust here (we follow your request: deduct from total claimed $DIA)
        // Update extraRate so dashboard can pick it up
        walletData.extraRate = Number((parseFloat(walletData.extraRate || 0) + CATALOG[itemKey].rate).toFixed(8));
        writeWalletData(wallet, walletData);
      } else {
        // fallback
        const newBal = Number((parseFloat(localStorage.getItem('diaBalance') || 0) - price).toFixed(8));
        localStorage.setItem('diaBalance', String(newBal));
        // also maintain fallback owned list
        let fallbackOwned = JSON.parse(localStorage.getItem('owned_fallback') || '[]');
        fallbackOwned.push(itemKey);
        localStorage.setItem('owned_fallback', JSON.stringify(fallbackOwned));
      }

      // persist ownership
      if (wallet) {
        const ownedArr = readOwned(wallet);
        // drill2 is stackable ‚Äî we will allow multiple buys so store counts by pushing
        ownedArr.push(itemKey);
        writeOwned(wallet, ownedArr);
      }

      // update UI immediately
      refreshAfterPurchase();
      alert('‚úÖ Purchased ' + CATALOG[itemKey].title + '. Price deducted.');
    }

    // Refresh UI and button states after purchase
    function refreshAfterPurchase() {
      const wallet = getActiveWallet();
      let spendableVal = 0;
      let unclaimedVal = 0;

      if (wallet) {
        const data = readWalletData(wallet) || {};
        spendableVal = parseFloat(data.totalDia || 0);
        unclaimedVal = parseFloat(data.balance || 0);
      } else {
        spendableVal = parseFloat(localStorage.getItem('diaBalance') || 0);
        unclaimedVal = 0;
      }

      updateSpendableUI(spendableVal, unclaimedVal);
      updateButtonsState();
      restoreOwnedUI(wallet);
    }

    // Init on page load
    window.addEventListener('DOMContentLoaded', () => {
      initMarketplace();

      // Keep UI in sync if some other tab updates localStorage (optional)
      window.addEventListener('storage', (e) => {
        // when wallet_data or owned keys change we refresh
        if (!getActiveWallet()) return;
        const wallet = getActiveWallet();
        if (e.key && (e.key.startsWith(wallet + '_') || e.key === 'diaBalance' || e.key === 'walletAddress')) {
          // small debounce
          setTimeout(() => { refreshAfterPurchase(); }, 100);
        }
      });
    });

  </script>
</body>
</html>
